<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no" />
    <title>ZIM JUMP</title>

    <!-- zimjs.com - JavaScript Canvas Framework -->
    <script type="module">
        import zim from "https://zimjs.org/cdn/017/zim_physics";

        // Initialize the game
        new Frame(FIT, 1024, 768, light, dark, ready);

        function ready() {
            // Initialize the physics world with proper gravity
            const physics = new Physics({
                gravity: 9.8,
                borders: "none" // We'll handle our own borders
            });
            
            // Background
            //const background = new Rectangle(S.width, S.height, "#87CEEB").center();
            
            // ZIM Shader background - using a solid color first
            // A circle - using rgb() and circle() functions
            const fragment = `
            // center will be wiggled outside in ZIM so need a uniform
            uniform vec2 center;

            // prepare a function to convert RGB 0-255 to 0-1
            vec3 rgb(float r, float g, float b) {
                return vec3(r/255.0, g/255.0, b/255.0); // 0-1
            }

            // prepare a function to see if each point (uv) is inside or outside radius
            // from wherever the center of the circle is located (pos - based on center uniform)
            vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {
                float d = length(pos - uv) - rad;
                float t = clamp(d, 0.0, 1.0); // threshhold 0 if within radius range from center
                return vec4(color, 1.0 - t); // alpha 0 if outside radius
            }

            void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
                // circle will be 1/2 the height
                float radius = 0.25 * iResolution.y;

                // Background
                vec4 layer1 = vec4(rgb(255.0, 165.0, 0.0), 1.0);

                // Circle
                vec3 red = rgb(255.0, 0.0, 0.0);
                vec4 layer2 = circle(fragCoord.xy, center, radius, red);

                // Blend the two using the alpha of the circle
                fragColor = mix(layer1, layer2, layer2.a);
            }
            `;

            const uniforms = {
            center:[W/2, H/2]
            };
            const u = new Uniforms(uniforms).wiggle("center_A", W/2, 50,100, 2,4);
            new Shader(W, H, fragment, u).center();

            
            // Background image (added after shader)
            //new Pic("assets/soccer-background.png").sca(2, 2).center().addTo(S);

            // game variables
            let score = 0;
            let jumpCount = 0;
            let gameStarted = false;
            let highScore = 0; // Track high score
            const maxJumps = 2; // maximum jumps allowed (regular + double jump)
            let gameOverFlag = false; // Add this at the top, outside the Ticker loop

            
            // Create the player (a jumping box)
            const player = new Rectangle(60, 60, interstellar)
                .centerReg()
                .pos(S.width/2, S.height - 150);
            
            player.addPhysics({
                density: 1,
                friction: 0.5,
                bounciness: 0.2,
                linear: 0.8,
                angular: 0.8
            });
            
            // Platform creation function
            function createPlatform(yPosition, width = 200, color = "blue") {
                const platform = new Rectangle(width, 20, color)
                    .centerReg()
                    .pos(Math.random() * (S.width - width) + width/2, yPosition);
                
                // Add static physics to platform
                platform.addPhysics({
                    dynamic: false, // Static platform
                    friction: 0.3
                });
                
                return platform;
            }

            // Create initial platforms
            const platforms = [];
            const platformSpacing = 150;
            
            // Create a starting platform (green and full width)
            const startPlatform = new Rectangle(S.width, 20, "green")
                .centerReg()
                .pos(0, S.height - 50);
                
            // Add static physics to platform
            startPlatform.addPhysics({
                dynamic: false, // Static platform
                friction: 0.3
            });
            
            platforms.push(startPlatform);
            
            // Create regular platforms
            for (let i = 0; i < 7; i++) {
                platforms.push(createPlatform(S.height - 250 - i * platformSpacing));
            }

            // Score display
            const scoreText = new Label({
                text: "Score: 0",
                size: 30,
                color: "white"
            }).pos(20, 20);
            
            // Jump counter display
            const jumpText = new Label({
                text: "Jumps: " + jumpCount + "/" + maxJumps,
                size: 20,
                color: "white"
            }).pos(20, 60);
            
            // Set up player control with keyboard for left/right movement
            player.control({
                type: "arrows",
                speed: 15,
                horizontal: true,
                vertical: false
            });
            
            // Space bar for jumping
            window.addEventListener("keydown", (e) => {
                if (e.code === "Space" && jumpCount < maxJumps) {
                    // Apply upward impulse for jump
                    player.body.SetLinearVelocity({
                        x: player.body.GetLinearVelocity().x,
                        y: -15
                    });
                    
                    jumpCount++;
                    jumpText.text = "Jumps: " + jumpCount + "/" + maxJumps;
                    
                    // Game has started once player jumps
                    gameStarted = true;
                }
            });
            
            // Handle screen wrapping for player
            Ticker.add(() => {
                // Handle screen wrapping (player going off the sides)
                if (player.x < -player.width/2) {
                    player.body.loc(S.width + player.width/2, player.y);
                }
                if (player.x > S.width + player.width/2) {
                    player.body.loc(-player.width/2, player.y);
                }
            });

            // Set up collision detection for platforms
            player.contact((other) => {
                // Check if the other object is a platform
                if (platforms.includes(other)) {
                    // Only reset jump count if player is moving downward (landing)
                    if (player.body.GetLinearVelocity().y > 0) {
                        // Check if player is above the platform
                        if (player.y < other.y - player.height/2) {
                            // Reset jump count when landing on a platform
                            jumpCount = 0;
                            jumpText.text = "Jumps: " + jumpCount + "/" + maxJumps;
                            
                            // Apply a small upward bounce
                            player.body.SetLinearVelocity({
                                x: player.body.GetLinearVelocity().x,
                                y: -10
                            });
                            
                            // Add points for landing on platforms
                            if (gameStarted && other !== startPlatform) {
                                score += 10;
                                scoreText.text = "Score: " + score;
                            }
                        }
                    }
                }
            });
            
            // Update platforms: recycle them when they go off-screen
            Ticker.add(() => {
                const cameraScrollThreshold = S.height / 2 - 100;
                
                // Scroll platforms down if player gets too high
                if (player.y < cameraScrollThreshold) {
                    // Move player back to threshold
                    const diff = cameraScrollThreshold - player.y;
                    player.body.loc(player.x, cameraScrollThreshold);
                    
                    // Move all platforms down by the same amount
                    platforms.forEach(platform => {
                        platform.body.loc(platform.x, platform.y + diff);
                    });
                    
                    // Update score based on how high player went
                    if (gameStarted) {
                        score += Math.round(diff);
                        scoreText.text = "Score: " + score;
                    }
                }
                
                // Check if platforms are below screen
                for (let i = platforms.length - 1; i >= 0; i--) {
                    const platform = platforms[i];
                    
                    // Don't remove starting platform until game has started
                    if (platform === startPlatform && !gameStarted) continue;
                    
                    if (platform.y > S.height + platform.height) {
                        // Find the highest platform
                        let highestY = S.height;
                        platforms.forEach(p => {
                            if (p.y < highestY) highestY = p.y;
                        });
                        
                        // Remove old platform
                        platform.removePhysics();
                        platform.removeFrom();
                        platforms.splice(i, 1);
                        
                        // Add new platform at the top
                        const newPlatform = createPlatform(
                            highestY - platformSpacing - Math.random() * 50
                        );
                        platforms.push(newPlatform);
                    }
                }
                

            // Game over check - only if player is below the screen and game has started
            if (gameStarted && player.y > S.height + 200 && !gameOverFlag) {
                gameOverFlag = true; // Set flag to true to prevent repeated calls
                gameOverTab(highScore); // Call game over tab once
            }

            });

            // Reset game function
            function resetGame() {
                // Reset the game over flag when restarting the game
                gameOverFlag = false;

                // Reset all game elements (platforms, player position, score, etc.)
                if (score > highScore) {
                    highScore = score;
                }

                // Reset player position and other game state
                player.body.loc(S.width / 2, S.height - 150);
                player.body.SetLinearVelocity({ x: 0, y: 0 });
                gameStarted = false;
                jumpCount = 0;
                jumpText.text = "Jumps: " + jumpCount + "/" + maxJumps;

                // Remove all platforms
                platforms.forEach(platform => {
                    platform.removePhysics();
                    platform.removeFrom();
                });
                platforms.length = 0;

                // Create new starting platform and reset score
                const newStartPlatform = new Rectangle(S.width, 20, "green")
                    .centerReg()
                    .pos(0, S.height - 50);
                newStartPlatform.addPhysics({
                    dynamic: false, // Static platform
                    friction: 0.3
                });
                platforms.push(newStartPlatform);

                // Create new platforms
                for (let i = 0; i < 7; i++) {
                    platforms.push(createPlatform(S.height - 250 - i * platformSpacing));
                }

                score = 0;
                scoreText.text = "Score: 0";
            }

            // Show game over tab
            function gameOverTab(highScore) {

            // Update high score if the current score exceeds it
            if (score > highScore) {
                highScore = score;
            }

            // Create the container with enough height to hold all elements
            const gameOverContainer = new Container(0, 0).pos(S.width / 2, S.height / 2); 

            // "Game Over!" label
            const gameOverLabel = new Label({
                text: "GAME OVER!",
                size: 40,
                color: black
            }).addTo(gameOverContainer).pos(0, -60, CENTER); // Positioned above the score and restart button

            // High Score label (display the updated high score)
            const highScoreLabel = new Label({
                text: "High Score: " + highScore,
                size: 30,
                color: white
            }).addTo(gameOverContainer).pos(0, -10, CENTER); // Positioned below the "Game Over" label

            // Restart button
            const restartButton = new Button({
                label: "Restart",
                width: 150,
                height: 40,
                backgroundColor: "orange",
                rollBackgroundColor: "orangered",
                corner: 8
            }).addTo(gameOverContainer).pos(0, 30, CENTER);

            // Attach the click event for restarting the game
            restartButton.on("click", () => {
                resetGame(); // Reset the game state
                gameOverContainer.removeFrom(S); // Remove the game over container
                // Optionally, you could re-add the background or reset other visual elements if necessary.
            });
            }

            // Instructions - split into two lines
            const instructions = new Container(S.width, 60).pos(S.width/2, 30, CENTER);
            
            new Label({
                text: "← → to Move | SPACE to Jump",
                size: 20,
                color: "white"
            }).addTo(instructions).pos(-145, 0, CENTER);
            
            new Label({
                text: "(Double Jump Available)",
                size: 20,
                color: "white"
            }).addTo(instructions).pos(-110, 28, CENTER);

            // Create Start Menu
            const startMenu = new Container(W,0).center();

            // Title
            const title = new Label({
                text: "ZIM JUMP",
                size: 50,
                color: "white",
                bold: true
            }).addTo(startMenu).pos(0, -100, CENTER);

            // Start Button
            const startButton = new Button({
                label: "Start Game",
                width: 200,
                height: 50,
                backgroundColor: "green",
                rollColor: "lime",
                corner: 10
            }).addTo(startMenu).pos(0, 0, CENTER);

            startButton.tap(() => {
                startMenu.removeFrom(); // Remove menu
                gameStarted = true;     // Start game
            });

        }
    </script>
</head>
<body></body>
</html>
